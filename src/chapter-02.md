# 第2章-基础  

当你深入研究`Rust`高级知识时, 对基础知识有扎实的理解非常重要. 与其他编程语言一样, 在`Rust`中, 当你开始以更复杂的方式使用该语言时, 各种关键字和概念的准确含义变得非常重要. 在本章中, 我们将浏览`Rust`的许多原语, 并试图更清晰地定义它们的含义, 工作原理, 以及它们的确切定义方式. 具体来说, 我们将了解变量和值区别, 它们在内存中的表示方式以及在程序的不同内存区域. 然后, 我们将讨论一些所有权、借用和生命周期的微妙之处, 在继续学习本书之前, 你需要掌握这些知识.

如果你愿意, 可以从上到下阅读本章, 也可以将本章作为参考资料, 以便温习你不太确定的概念. 我建议你在完全掌握本章内容后再继续阅读, 因为对这些原语工作原理的误解会很快影响你对更高级主题的理解, 或者导致你错误地使用这些原语.

## 谈谈内存  

并非所有内存都是一样的. 在大多数编程环境中, 你的程序可以访问栈(`stack`)、堆(`heap`)、寄存器(`register`)、文本段(`text segment`)、内存映射的寄存器(`memory-mapped register`)、内存映射的文件(`memory-mapped file`), 也许还有非易失性 `RAM`(`Nonvolatile RAM`). 在特定情况下, 你选择使用哪一种会影响到你能其中存储什么, 它能存储多久, 以及您使用什么机制来访问它. 这些内存区域的具体细节因平台而异且也超出了本书的范围, 但有些内存区域对`Rust`代码的推理非常重要, 因此值得在此介绍.

### 内存术语  

在我们深入研究内存区域之前, 你首先需要了解值、变量和指针之间的区别. `Rust`中的值是一个类型和该类型的值域的一个元素的组合. 一个值可以使用其类型的表示法变成字节序列, 但就其本身而言, 你可以认为一个值更像是你,程序员的含义的值的意思. 例如, `u8` 类型中的数字 `6` 是数学整数 `6` 的一个实例, 它在内存中的表示是字节 `0x06`. 同样, 字符串"Hello world"是所有字符串域中的一个值, 其表示方法是`UTF-8`编码. 一个值的意义与这些字节存储的位置无关.

一个值被存储在一个位置中, 这是`Rust`的术语, 意思是: "一个可以容纳一个值的位置". 这个位置可以在栈中, 也可以在堆上, 或者其他位置. 最常见的值存储位置是一个变量, 它是栈上的一个命名值槽.

指针是一个持有内存区域地址的数值, 因此指针指向一个地方. 指针可以被解引用, 以访问存储在它所指向的内存位置的值. 我们可以在多个变量中存储同一个指针, 因此有多个变量间接地指向内存中的同一个位置, 从而指向同一个底层值.

请看清单 1-1 中的代码, 它说明了这三个要素.

```rust
let x = 42;
let y = 43;
let var1 = &x;
let mut var2 = &x;
var2 = &y; // (1)

// 清单 1-1：值、变量和指针
```

这里有四个不同的值. `42`(一个`i32`), `43`(一个`i32`), `x` 的地址(一个指针), 以及 `y` 的地址(一个指针). 还有四个变量：`x`、`y`、`var1` 和 `var2`. 后两个变量都持有指针类型的值, 因为引用是指针. 虽然 `var1` 和 `var2` 最初存储的是同一个值, 但它们分别存储该值的独立副本；当我们改变 `var2`(1)中存储的值时, `var1` 中的值不会改变. 尤其是`=` 运算符, 它将右侧表达式的值存储在左侧命名的地方.

一个有趣的例子可以说明变量、值和指针之间的区别有多重要，比如在下面的语句中：

```rust
let string = "Hello world";
```

尽管我们给变量 `string` 赋值, 但该变量的实际值是持有字符串值 "Hello world "中第一个字符的指针, 而不是字符串值本身. 这时你可能会说："等等, 那么字符串值存储在哪里呢？指针指向哪里？" 如果是这样的话, 你的眼光就很敏锐了--我们稍后再谈这个问题.

> NOTE: 从技术上讲，字符串还包括字符串的长度. 我们将在第 3 章讨论胖指针类型时讨论这个问题.  

### 深入了解变量

我前面给出的变量定义很宽泛, 本身不太可能有什么用. 当你遇到更复杂的代码时, 你将需要一个更准确的心智模型来帮助你推理出程序的真正在做什么. 我们可以利用许多这样的模型. 详细描述它们将耗费几章的篇幅, 也超出了本书的范围, 但大体上可以将它们分为两类：高层模型(`High-level`)和低层模型(`low-level`). 高层模型考虑生命周期和借用层面的代码时很有用, 而低层模型则适用推理不安全代码和原始指针. 下面两节描述的变量模型足够满足本书的大部分内容的需要.

#### 高层模型

在高级模型中, 我们不认为变量是存放字节的地方. 相反，当变量在整个程序中被实例化、移动和使用时，我们把它们看作是赋予值的名称. 当你给一个变量赋值的时候, 这个值就从此由该变量命名了. 当以后访问变量时, 你可以想象从该变量的先前访问到新的访问画一条线, 这在两次访问之间建立了一种依赖关系. 如果变量中的值被移动了, 就不能再从该变量中画线了.

在这个模型中, 变量只有在持有合法值的情况下才会存在；如果变量值未初始化或已被移动，则无法从该变量中画线，因此实际上它并不存在. 使用这种模型，你的整个程序由许多这样的依赖线组成，通常称为流，每个流都会追踪一个值的特定实例的生命周期. 当存在分支时，流可以分叉和合并，每个分叉都会跟踪该值的不同生命周期. 编译器可以检查在程序的任何给定点, 所有可以并行存在的流是否兼容. 例如，不能有两个并行的流程对一个值进行可变访问. 也不能存在借用值的流程，而没有拥有该值的流程. 清单 2-2 显示了这两种情况的示例.

```rust
let mut x;
// 这是非法的, 没有地方可以获取流
// assert_eq!(x, 42);
x = 42;     // (1)
// 这是正确的, 可以从上面分配的值中画出一个流. 
let y = &x; // (2)
// 这就建立了第二个来自 x 的、可变的流. 
x = 43;     // (3)
// 这样就继续从 y 那里获得流, 而 y 又从 x 那里获得流.  
// 但这条流与对 x 的分配相冲突！
assert_eq!(*y, 42); // (4)

// 清单 1-2：借用检查器会发现的非法流
```

首先, 在 `x` 被初始化之前, 我们不能使用它, 因此我们无法绘制流. 只有当我们给 `x` 赋值时, 我们才能从它那里提取流. 这段代码有两个流：一个从 `(1)` 到 `(3)` 的独占(`&mut`)流, 一个从 `(1)` 到 `(2)` 到 `(4)` 的共享(`&`)流.  借用检查器检查每个流的每个顶点, 并检查是否有其他不兼容的流同时存在. 在本例中, 当借用检查器检查 `(3)` 处的独占流时, 它看到了终止于 `(4)` 处的共享流. 由于你不能同时独占和共享使用同一个值, 借用检查器(正确地)拒绝了该代码. 请注意, 如果没有 `(4)`, 这段代码的编译也不会有问题. 共享流将在 `(2)` 处终止, 而当独占流在 `(3)` 处被检查时, 就不会存在有冲突的流.

如果声明的新变量与之前的变量同名, 它们仍被视为不同的变量. 这被称为 "shadows"(遮蔽) -- 后一个变量 "shadows"(遮蔽)了前一个同名的变量. 这两个变量共存, 但后续代码无法再使用先前的变量. 这个模型与编译器, 特别是借用检查器, 对你的程序的推理大致吻合,  编译器内部使用这种模式来生成高效的代码.

#### 底层模型

变量可以命名内存位置，这些位置可能包含合法值，也可能不包含合法值. 你可以把变量看作一个 “值槽”. 当你给它赋值时, 槽被填满, 它的旧值(如果有的话)就会被丢弃和替换. 访问变量时, 编译器会检查该槽是否为空, 因为这意味着该变量未被初始化或其值已被移动. 变量指针持有的是该变量的后备内存, 可以被解引用以获得其值. 例如, 在语句 `let x: usize` 中, 变量 `x` 是栈上一个内存区域的名称, 该区域有空间容纳一个 `usize` 大小的值, 尽管它没有一个明确的值(其槽是空的). 如果你给这个变量赋值, 比如 `x = 6`, 那么这个内存区域就会容纳代表值 `6` 的比特. 这个模型与 C 和 C++以及其他许多低级语言所使用的内存模型相匹配, 当你需要明确推理内存时很有用.

> 注意：在本例子中, 我们忽略了 CPU 寄存器, 并将其视为一种优化. 实际上,  如果一个变量不需要内存地址, 编译器可能会使用一个寄存器来支持该变量, 而不是一个内存区域.

你可能会发现其中一个比另一个更适合你之前的模型, 但我建议你试着仔细理解这两个模型. 它们都是同样有效的, 而且都是简化的, 就像任何有用的心智模型一样. 如果您能从这两个角度来考虑一段代码，您就会发现在处理复杂的代码段时会容易得多，也更容易理解为什么它们能或不能按照您的预期编译和运行.

### 内存区域

现在你已经掌握了我们如何称呼内存, 我们需要谈谈内存到底是什么. 内存有许多不同的区域, 也许令人惊讶的是, 并不是所有的区域都存储在你的计算机的`DRAM`中. 使用内存的哪个部份对你如何编写代码有重大影响. 就编写`Rust`代码而言, 三个最重要的区域是栈、堆和静态内存.

#### 栈

栈是一段内存, 程序使用它作为函数调用的临时空间. 每次调用函数时, 都会在栈的顶部分配一块连续的内存, 称为帧. 接近栈底部的是主函数的帧, 当函数调用其他函数时, 额外的帧被推送到栈中. 函数的帧包含该函数中的所有变量, 以及该函数接的所有参数. 当函数返回时, 它的栈帧被回收.

构成函数局部变量值的字节不会立即被清除, 但访问它们是不安全的, 因为它们可能被随后的函数调用覆盖, 而后续函数调用的帧与回收的帧重叠. 即使它们没有被覆盖, 它们也可能包含非法使用的值, 例如在函数返回时被移动的值.

栈帧, 以及它们最终会消失这一关键事实, 与 `Rust` 中的生存期概念密切相关. 任何存储在栈帧中的变量在该帧消失后都无法被访问, 所以任何对它的引用都必须有一个与栈帧生命周期一样长的生存期.

#### 堆

堆是与程序当前调用栈无关的内存池. 堆内存中的值会一直存在, 直到它们被显式地回收. 当您希望某个值存在超过当前函数帧的生命周期时结束后继续存在时, 这是很有用的. 如果该值是函数的返回值, 调用函数可以在其栈上留下一些空间, 以便被调用函数在返回之前将该值写入其中. 但如果你想, 将该值发送到一个不同的线程, 而当前线程可能根本不共享栈帧, 你可以把它存储在堆上.

堆允许您显式地分配连续的内存段. 分配时, 你会得到一个指向该内存段起点的指针. 该内存段将为你保留, 直到你以回收它；这个过程通常被称为释放, 与`C`标准库中相应函数的名称相同. 由于从堆中分配的内存不会在函数返回时消失, 所以您可以在一个地方为一个值分配内存, 然后将指向该值的指针传递给另一个线程, 并让该线程安全地继续对该值进行操作. 或者, 换句话说, 当你堆分配内存时, 所产生的指针有一个不受约束的生命周期——无论你的程序让它存活多长时间，它的生命周期都是一样的.

在 `Rust` 中与堆交互的主要机制是 `Box` 类型. 当您写入 `Box::new(value)` 时, 该值被放在堆上, 而返回给您的 (`Box<T>`) 是指向堆上该值的指针. 当 `Box` 最终被丢弃时, 内存将被回收.

如果你忘记回收堆内存, 它将会一直存在, 你的应用程序最终会吃掉你机器上的所有内存. 这被称为泄漏内存, 通常是你想要避免的. 然而, 在有些情况下, 你会明确地想要泄漏内存. 例如, 你有一个整个程序都能访问的只读配置. 你可以在堆上分配这个配置, 然后用 `Box::leak` 显式地泄露它, 以获得一个 "静态引用"(`'static`).

#### 静态内存

静态内存实际上是程序编译文件中几个密切相关区域的总称. 程序执行时，这些区域会自动加载到程序的内存中. 静态内存中的值在程序的整个执行过程中都会存在. 程序的静态内存包含程序的二进制代码，通常映射为只读. 程序在执行过程中，会逐条指令读取文本段中的二进制代码，并在调用函数时跳转. 静态内存还包含用`static`关键字声明的变量的内存，以及代码中的某些常量值，如字符串.

特殊的生命周期 `'static`的名称来自静态内存区域, 它将引用标记为"只要静态内存还存在"就有效, 也就是直到程序关闭. 由于静态变量的内存是在程序启动时分配的, 所以对静态内存中变量的引用定义为 `'static`, 因为在程序关闭之前它不会被释放. 反之则不然, 也可能会有不指向静态内存的 `'static` 引用, 但这个名字仍然是合适的：一旦你创建了一个具有静态寿命的引用, 就程序的其他部分而言, 它所指向的东西可能就在静态内存中, 因为它可以被使用多长时间, 你的程序就会使用多长时间.

在使用 `Rust` 时, `'static`生命周期比真正的静态内存(例如, 通过 `static` 关键字)更常见. 这是因为 `static` 经常出现在类型参数的 `trait` 约束中. 像 `T: 'static` 这样的约束表示, 类型参数 `T` 能够存活, 我们就保留它多久, 包括程序的剩余执行时间. 本质上, 这个限定要求 `T` 是拥有(owned)的和自给自足(self-sufficient)的, 要么它不借用其他(非静态)值, 要么它借用的任何东西也是 `'static`, 因此会一直保留到程序结束. `'static` 作为约束的一个很好的例子是 `std::thread::spawn` 函数, 它创建了一个新的线程, 它要求传递给它的闭包是 `'static` . 由于新线程的生存期可能比当前线程长, 因此新线程不能引用存储在旧线程堆栈上的任何内容. 新线程只能引用在其整个生命周期内(可能是在程序的剩余时间内)都有效的值.

> 注意：您可能想知道 `const` 与 `static` 有何不同.  `const` 关键字将以下项目声明为常量. 常量项可以在编译时完全计算出来, 任何引用常量的代码都将在编译期间替换为常数的计算值. 常量没有与之关联的内存或其他存储空间(它不是一个位置). 您可以将常量看作是特定值的方便名称.

## 所有权

Rust 的内存模型的核心思想是所有值都只有一个所有者, 也就是说, 只有一个位置(通常是一个作用域)负责最终回收每个值. 这一点通过借用检查器强制执行的. 如果值被移动, 例如将其赋值给一个新变量、将其推入`vector`(向量)或将其放在堆上, 则值的所有权将从旧位置移动到新位置. 此时, 尽管构成值的位置在技术上仍然存在，但你不能再通过来自原所有者的变量访问该值. 相反, 您必须通过引用其新位置的变量来访问被移动的值.

有些类型是叛逆者, 不遵守这条规则. 如果值的类型实现了特殊的 `Copy` `trait,` 即使它被重新分配到一个新的内存位置, 它也不会被视为移动. 相反, 该值被复制, 新旧位置仍然可访问. 从本质上说, 在移动的目的地构造了另一个相同值的相同实例. `Rust` 中大多数基本类型(如整数和浮点类型)都是 `Copy` 类型. 要成为 `Copy` 类型, 必须能够简单地通过复制其比特来复制该类型的值. 这排除了所有包含非 `Copy` 类型的类型, 以及任何在值被丢弃时拥有必须回收资源的类型.

要知道为什么, 请考虑一下如果像 `Box` 这样的类型是`Copy`, 会发生什么. 如果我们执行 `box2 = box1`, 那么 `box1` 和 `box2` 都会认为他们拥有为 `box` 分配的堆内存, 当他们超出范围时, 他们都会试图释放它. 释放两次内存可能会产生灾难性的后果.

当一个值的所有者不再使用它时, 该所有者有责任通过丢弃该值来对该值进行必要的清理. 在 `Rust` 中, 当持有该值的变量不再处于作用域中时, 就会自动丢弃该值. 类型通常递归地丢弃它们所包含的值, 因此丢弃一个复杂类型的变量可能会导致许多值被丢弃. 由于 `Rust` 的离散所有权要求, 我们不能意外地多次丢弃同一个值. 持有另一个值引用的变量并不拥有另一个值, 因此当变量删除时, 该值不会被丢弃.

清单 1-3 中的代码给出了围绕所有权、移动和复制语义以及放弃的规则的快速总结.

```rust
let x1 = 42;
let y1 = Box::new(84);
{  // 开始一个新的作用域
  let z = (x1, y1); // (1)
  // z 离开作用域, 并被丢弃；
  // 它一次析构了 x1 和 y1 中的值
} // (2)
// x1 的值是 Copy 语义,  所以它不会移动给 z
let x2 = x1; // (3)
// y1 的值不是 Copy 语义, 所以它会移动给 z
// let y2 = y1; // (4)

// 清单 1-3: 移动和复制语义
```

一开始, 我们有两个值, 数字 `42` 和包含数字 `84` 的 `Box`(堆分配的值). 前者是`Copy`, 而后者不是. 当我们将`x1` 和 `y1` 放入元组 `z1`时, `x1` 被复制到 `z` 中, 而 `y1` 被移动到 `z` 中. 此时, `x1` 继续可访问, 并可以再次使用 (3) . 另一方面, 一旦 `y1` 的值被移动到 (4), 它就变得不可访问, 任何访问它的尝试都将导致编译器错误. 当 `z` 超出范围 (2) 时, 它所包含的元组值将被丢弃, 这将依次丢弃从 `x1` 复制的值和从 `y1` 移动的值. 当 `y1` 中的 `Box` 被丢弃时, 它还释放用于存储 `y1` 值的堆内存.

>丢弃顺序
>
>Rust 会自动丢弃超出作用域的值, 比如清单 2-3 中内部作用域的 `x1` 和 `y1`. 丢弃顺序的规则相当简单：变量(包括函数参数)按相反的顺序丢弃, 嵌套值按源代码的顺序丢弃.
>
>这听起来可能很奇怪, 为什么会有这样的差异？不过, 如果我们仔细研究一下, 就会发现它很有道理. 假设你编写了一个函数, 声明了一个字符串, 然后将该字符串的引用插入到一个新的哈希表中. 当函数返回时, 哈希表必须先被丢弃；如果字符串先被丢弃, 那么哈希表就会持有一个无效的引用! 一般来说, 后来的变量可能包含对早期值的引用, 而由于 `Rust` 的生命周期规则, 反之则不能发生. 出于这个原因, `Rust` 以相反的顺序丢弃变量.
>
>现在, 我们可以对嵌套的值(如元组、数组或结构体中的值）)有同样的行为, 但这可能会让用户感到惊讶. 如果你构建了一个包含两个值的数组, 如果数组的最后一个元素先被丢弃, 那就显得很奇怪. 这同样适用于元组和结构, 最直观的行为是第一个元组元素或字段先被丢弃, 然后是第二个, 以此类推. 与变量不同的是, 在这种情况下没有必要颠倒丢弃顺序, 因为 `Rust`(目前)不允许在单个值中进行自我引用. 所以, `Rust` 采用了直观的选项.
